#!/bin/bash
#
# /etc/rc.sysinit
#

. /etc/rc.conf
. /etc/rc.d/functions

echo " "
printhl "Induction Linux\n"
printhl "${C_H2}http://www.inductionlinux.org/"
printsep

run_hook sysinit_start

# export standard PATH (will be overridden later when /etc/profile is sourced, but is usefull for UDev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# mount /proc, /sys and our RAM /dev
/bin/mountpoint -q /proc || /bin/mount -n -t proc proc /proc -o nosuid,noexec,nodev
/bin/mountpoint -q /sys  || /bin/mount -n -t sysfs sysfs /sys -o nosuid,noexec,nodev

if ! /bin/mountpoint -q /dev; then
  if grep -q devtmpfs /proc/filesystems 2>/dev/null; then
    /bin/mount -n -t devtmpfs udev /dev -o mode=0755,size=10M,nosuid
  else
    /bin/mount -n -t tmpfs udev /dev -o mode=0755,size=10M,nosuid
  fi
fi

# start up our mini logger until syslog takes over
/sbin/minilogd

# anything more serious than KERN_WARNING goes to the console
# 'verbose' cmdline parameter enables more messages
if /bin/grep -q " verbose" /proc/cmdline; then
	/bin/dmesg -n 8
else
	/bin/dmesg -n 3
fi

HWCLOCK_PARAMS="--hctosys"
case $HARDWARECLOCK in
    UTC) HWCLOCK_PARAMS+=" --utc";;
    localtime) HWCLOCK_PARAMS+=" --localtime";;
    *) HWCLOCK_PARAMS="";;
esac

if [[ $HWCLOCK_PARAMS ]]; then
	# enable rtc access
	/sbin/modprobe -q -a rtc-cmos rtc genrtc
	# If devtmpfs is used, the required RTC device already exists now
	# Otherwise, create whatever device is available
	if ! [[ -c /dev/rtc || -c /dev/rtc0 ]]; then
            for dev in /sys/class/rtc/rtc0/dev /sys/class/misc/rtc/dev; do
                [[ -e $dev ]] || continue
		IFS=: read -r major minor < "$dev"
		/bin/mknod /dev/rtc c $major $minor
	    done
	fi

	# Do a clock set here for a few reasons:
	# 1. Make creation time on udev nodes sane (FS#8665)
	# 2. Filesystem checks can depend on system time
	# 3. This will set the clock, if using non-UTC, off the last known
	#    configured timezone. Any new timezone put in rc.conf is copied over at
	#    a later time.
	# This does *NOT* take into account a time adjustment file as /var may not be
	# mounted yet. A second set occurs later to match rc.conf.
	if [[ -f /etc/localtime ]]; then
		/sbin/hwclock $HWCLOCK_PARAMS --noadjfile
	fi
fi

echo > /proc/sys/kernel/hotplug

stat_busy "Starting UDev Daemon"
/sbin/udevd --daemon
stat_done

run_hook sysinit_udevlaunched

# Trigger udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
  stat_busy "Triggering UDev uevents"
  /sbin/udevadm control --property=STARTUP=1
  /sbin/udevadm trigger --action=add --type=devices
  /sbin/udevadm trigger --action=add --type=subsystems
  stat_done
fi

# Load modules from the MODULES array defined in rc.conf
mods=${MODULES[@]/!*/}
if [[ $load_modules != off && -f /proc/modules && $mods ]]; then
	stat_busy "Loading Modules"
	/sbin/modprobe --all $mods
	stat_done
fi
unset mods

# Wait for udev uevents
if /bin/pidof -o %PPID /sbin/udevd >/dev/null; then
	stat_busy "Waiting for UDev uevents to be processed"
	/sbin/udevadm settle
	/sbin/udevadm control --property=STARTUP=
	stat_done
fi

run_hook sysinit_udevsettled

# bring up the loopback interface
[[ -d /sys/class/net/lo ]] && \
    status "Bringing up loopback interface" /sbin/ifconfig lo 127.0.0.1 up

# If necessary, find md devices and manually assemble RAID arrays
if [[ -f /etc/mdadm.conf ]] && /bin/grep -q ^ARRAY /etc/mdadm.conf; then
	status "Activating RAID arrays" /sbin/mdadm --assemble --scan
fi

activate_vgs

# Set up non-root encrypted partition mappings
if [[ -f /etc/crypttab && $CS && -n $(/bin/grep -v ^# /etc/crypttab | /bin/grep -v ^$) ]]; then
	/sbin/modprobe -q dm-crypt 2>/dev/null
	stat_busy "Unlocking encrypted volumes:"
		do_unlock() {
			# $1 = requested name
			# $2 = source device
			# $3 = password
			# $4 = options
			stat_append "${1}.."
			local open=create a="$1" b="$2" failed=0
			# Ordering of options is different if you are using LUKS vs. not.
			# Use ugly swizzling to deal with it.
			# isLuks only gives an exit code but no output to stdout or stderr.
			if $CS isLuks "$2" 2>/dev/null; then
				open=luksOpen
				a="$2"
				b="$1"
			fi
			case $3 in
				SWAP)
					local _overwriteokay=0
					if [[ -b $2 && -r $2 ]]; then
						# This is DANGEROUS! If there is any known file system,
						# partition table, RAID or LVM volume on the device
						# we don't overwrite it.
						#
						# 'blkid' returns 2 if no valid signature has been found.
						# Only in this case we should allow overwriting the device.
						#
						# This sanity check _should_ be sufficient, but it might not.
						# This may cause dataloss if it is not used carefully.
						/sbin/blkid -p "$2" &>/dev/null
						if [[ $? -eq 2 ]]; then
							_overwriteokay=1
						fi
					fi
					if [[ $_overwriteokay -eq 0 ]]; then
						false
					elif $CS -d /dev/urandom $4 $open "$a" "$b" >/dev/null; then
						stat_append "creating swapspace.."
						/sbin/mkswap -f -L $1 /dev/mapper/$1 >/dev/null
					fi;;
				ASK)
					printf "\nOpening '$1' volume:\n"
					$CS $4 $open "$a" "$b" < /dev/console;;
				/dev*)
					ckdev=${3%%:*}
					cka=${3#*:}
					ckb=${cka#*:}
					cka=${cka%:*}
					ckfile=/dev/ckfile
					ckdir=/dev/ckdir
					case ${cka} in
						*[!0-9]*)
							# Use a file on the device
							# cka is not numeric: cka=filesystem, ckb=path
							/bin/mkdir ${ckdir}
							/bin/mount -r -t ${cka} ${ckdev} ${ckdir}
							/bin/dd if=${ckdir}/${ckb} of=${ckfile} >/dev/null 2>&1
							/bin/umount ${ckdir}
							/bin/rmdir ${ckdir};;
						*)
							# Read raw data from the block device
							# cka is numeric: cka=offset, ckb=length
							/bin/dd if=${ckdev} of=${ckfile} bs=1 skip=${cka} count=${ckb} >/dev/null 2>&1;;
					esac
					$CS -d ${ckfile} $4 $open "$a" "$b" >/dev/null
					/bin/dd if=/dev/urandom of=${ckfile} bs=1 count=`stat -c %s ${ckfile}` conv=notrunc >/dev/null 2>&1
					rm ${ckfile};;
				/*)
					$CS -d "$3" $4 $open "$a" "$b" >/dev/null;;
				*)
					echo "$3" | $CS $4 $open "$a" "$b" >/dev/null;;
			esac
			if (($? != 0)); then
				failed=1
				stat_append "failed "
			else
				stat_append "ok "
			fi
			return $failed
		}
	crypto_unlocked=0
	if read_crypttab do_unlock; then
		stat_done
	else
		stat_fail
	fi
	if [[ ${crypto_unlocked} -eq 1 ]]; then
		# Maybe someone has LVM on an encrypted block device
		activate_vgs
	fi
fi

status "Mounting Root Read-only" /bin/mount -n -o remount,ro /

FORCEFSCK=
[[ -f /forcefsck ]] && FORCEFSCK="-- -f"
NETFS="nonfs,nonfs4,nosmbfs,nocifs,nocodafs,noncpfs,nosysfs,noshfs,nofuse,nofuseblk,noglusterfs"

fsck_reboot() {
	echo "Automatic reboot in progress..."
	/bin/umount -a
	/bin/mount -n -o remount,ro /
	/sbin/reboot -f
	exit 0
}

if [[ -x /sbin/fsck ]]; then
	stat_busy "Checking Filesystems"
	FSCK_OUT=/dev/stdout
	FSCK_ERR=/dev/stdout
	FSCK_FD=
	run_hook sysinit_prefsck
	/sbin/fsck -A -T -C$FSCK_FD -a -t "$NETFS,noopts=_netdev" $FORCEFSCK >$FSCK_OUT 2>$FSCK_ERR
	fsckret=$?
	if ((fsckret > 1)); then
		stat_fail
	fi
	run_hook sysinit_postfsck
	if (( ( fsckret & 2) == 2)); then
		echo
		echo "********************** REBOOT REQUIRED *********************"
		echo "*                                                          *"
		echo "* The system will be rebooted automatically in 15 seconds. *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		/bin/sleep 15
		fsck_reboot
	elif ((fsckret > 1 && fsckret != 32)); then
		echo
		echo "*****************  FILESYSTEM CHECK FAILED  ****************"
		echo "*                                                          *"
		echo "*  Please repair manually and reboot. Note that the root   *"
		echo "*  file system is currently mounted read-only. To remount  *"
		echo "*  it read-write type: mount -n -o remount,rw /            *"
		echo "*  When you exit the maintenance shell the system will     *"
		echo "*  reboot automatically.                                   *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		/sbin/sulogin -p
		fsck_reboot
	fi
	stat_done
fi

stat_busy "Mounting Local Filesystems"
/bin/mount -n -o remount,rw /
if [ -x /bin/findmnt -a -e /proc/self/mountinfo ]; then
	/bin/findmnt -rnu -o SOURCE,TARGET,FSTYPE,OPTIONS >| /etc/mtab
else
	cat /proc/mounts >| /etc/mtab
fi
run_hook sysinit_premount
# now mount all the local filesystems
/bin/mount -a -t $NETFS -O no_netdev
stat_done

# enable monitoring of lvm2 groups, now that the filesystems are mounted rw
if [[ $USELVM =~ yes|YES && -x /sbin/lvm && -d /sys/block ]]; then
	stat_busy "Activating monitoring of LVM2 groups"
	if /sbin/vgchange --monitor y >/dev/null; then
		stat_done
	else
		stat_fail
	fi
fi

status "Retrying failed UDev events" /sbin/udevadm trigger --action=add --type=failed

status "Activating Swap" /sbin/swapon -a

stat_busy "Configuring System Clock"
if [[ $TIMEZONE && -e /usr/share/zoneinfo/$TIMEZONE ]]; then
	/bin/rm -f /etc/localtime
	/bin/cp "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
fi

clock_pid=""
if [[ $HWCLOCK_PARAMS ]]; then
	# This time, we set the clock for real. Use the adjustment file now that
	# /var will definitely be available, and then set the system clock once
	# the hardware clock has been adjusted accordingly. The backgrounding magic
	# is due to the fact that the second call to hwclock will almost always
	# take ~1 second because of the clock granularity, and we might as well
	# stay busy.
	(
	/sbin/hwclock --adjust
	/sbin/hwclock $HWCLOCK_PARAMS
	) &
	clock_pid=$!
fi
stat_done

RANDOM_SEED=/var/lib/misc/random-seed
if [[ -f $RANDOM_SEED ]]; then
	stat_busy "Initializing Random Seed"
	/bin/cat $RANDOM_SEED > /dev/urandom
	stat_done
fi

stat_busy "Removing Leftover Files"
/bin/rm -f /etc/nologin &>/dev/null
/bin/rm -f /etc/shutdownpid &>/dev/null
/bin/rm -f /var/lock/* &>/dev/null
/bin/rm -rf /tmp/* /tmp/.* &>/dev/null
/bin/rm -f /forcefsck &>/dev/null
[[ -d /var/run ]] && /usr/bin/find /var/run/ \! -type d -delete
: >| /var/run/utmp
/bin/chmod 0664 /var/run/utmp
# Keep {x,k,g}dm happy with xorg
/bin/mkdir -m1777 /tmp/.{X11,ICE}-unix
stat_done

#status "Updating Shared Library Links" /sbin/ldconfig

if [[ $HOSTNAME ]]; then
	status "Setting Hostname: $HOSTNAME" /bin/hostname "$HOSTNAME"
fi

# Set the NIS domain name, if necessary
[[ -f /etc/conf.d/nisdomainname ]] && . /etc/conf.d/nisdomainname
if [[ $NISDOMAINNAME ]]; then
	status "Setting NIS Domain Name: $NISDOMAINNAME" /bin/nisdomainname "$NISDOMAINNAME"
fi

status "Updating Module Dependencies" /sbin/depmod -A

# Flush old locale settings
: >| /etc/profile.d/locale.sh
/bin/chmod 755 /etc/profile.d/locale.sh
# Set user defined locale
[[ $LOCALE ]] || LOCALE="en_US"
stat_busy "Setting Locale: $LOCALE"
echo "export LANG=$LOCALE" >>/etc/profile.d/locale.sh
stat_done

if [[ ${LOCALE,,} =~ utf ]]; then
	stat_busy "Setting Consoles to UTF-8 mode"
	# UTF-8 consoles are default since 2.6.24 kernel
	# this code is needed not only for older kernels,
	# but also when user has set vt.default_utf8=0 but LOCALE is *.UTF-8.
	for i in /dev/tty[0-9]*; do
		/usr/bin/kbd_mode -u < ${i}
		printf "\033%%G" > ${i}
	done
	echo 1 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q -u "$KEYMAP"
else
	stat_busy "Setting Consoles to legacy mode"
	# make non-UTF-8 consoles work on 2.6.24 and newer kernels
	for i in /dev/tty[0-9]*; do
		/usr/bin/kbd_mode -a < ${i}
		printf "\033%%@" > ${i}
	done
	echo 0 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q $KEYMAP
fi

# Set console font if required
set_consolefont

# Adding persistent network/cdrom generated rules
for f in cd net; do
    [[ -f /dev/.udev/tmp-rules--70-persistent-$f.rules ]] || continue
    stat_busy "Adding persistent $f udev rules"
    /bin/cat "/dev/.udev/tmp-rules--70-persistent-$f.rules" >> "/etc/udev/rules.d/70-persistent-$f.rules"
    stat_done
done

/bin/dmesg >| /var/log/dmesg.log

# final hwclock setting needs to be done at this point
if [[ $clock_pid ]]; then
	wait $clock_pid
fi

run_hook sysinit_end

# End of file
# vim: set ts=2 sw=2 noet:
